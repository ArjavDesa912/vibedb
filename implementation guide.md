üõ∏ VibeDB: Technical Specification & Implementation GuideVersion: 1.0.0Target: Single-binary, high-performance, "Schema-Later" DatabaseCore Stack: Rust, libSQL (SQLite Evolution), Axum, TokioüèóÔ∏è 1. System ArchitectureVibeDB functions as an intelligent proxy layer over libSQL. It treats incoming JSON as the "Source of Truth" and dynamically mutates the underlying relational schema to fit the data.Core ComponentsVibe-Ingestor (Axum): Handles HTTP/WebSocket traffic.Schema-Brain: Inspects JSON payloads and generates delta-migrations.Migration-Automaton: Executes ALTER TABLE statements within a safety wrapper.The Vibe-Store: Manages the persistent .db file using WAL mode for concurrent high-throughput.Vibe-Explorer: An embedded WebAssembly (WASM) dashboard for real-time data visualization.üõ†Ô∏è 2. Step-by-Step Implementation RoadmapPhase 1: Foundation & Dependency ManagementThe project must prioritize speed and safety. Use the following Cargo.toml baseline:Ini, TOML[dependencies]
tokio = { version = "1", features = ["full"] }
libsql = "0.6.0"
axum = "0.7"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
dashmap = "5.5" # Thread-safe schema caching
anyhow = "1.0"  # Error handling
tower-http = { version = "0.5", features = ["cors", "trace"] }
rust-embed = "8.0" # For embedding the Vibe-Explorer UI
Phase 2: The Inference Engine (inference.rs)To prevent data loss, the engine must map JSON types to SQLite-compatible types.JSON TypeSQLite AffinityLogic/ConstraintNumber (Integer)INTEGERCheck if is_i64Number (Float)REALDefault for any decimalBooleanINTEGERStore as 1 or 0StringTEXTStandard UTF-8Object / ArrayTEXT (JSON)Serialize to String; optionally use libSQL JSON functionsNullNULLIgnored during column creationConstraint: If a field is an Object/Array, the system should store it as a string but flag it for the Vibe-Explorer to treat as a nested structure.Phase 3: The Schema-Later Guard (guard.rs)This module is the "Heart" of VibeDB. It must follow this execution loop for every write:Cache Check: Check DashMap<String, Vec<String>> to see if the table and column list are already known.Live Verify (On Cache Miss): Run PRAGMA table_info(table_name).Diffing: Compare incoming_payload.keys() against existing_columns.Auto-Migration: If keys are missing, generate:SQLALTER TABLE {table} ADD COLUMN {key} {type} DEFAULT NULL;
Validation: Use sqlparser or a regex check to ensure keys are valid SQL identifiers (no spaces, no reserved keywords).Phase 4: The Vibe-API (api.rs)The API must be idempotent.Endpoint: POST /v1/push/:collectionLogic:Initialize table if it doesn't exist: CREATE TABLE IF NOT EXISTS {collection} (id INTEGER PRIMARY KEY AUTOINCREMENT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP).Pass payload to Schema-Brain.Execute INSERT INTO using positional parameters (?) to prevent SQL injection.üìä 3. The Vibe-Explorer (Embedded Visualizer)The Explorer is a "No-Configuration" dashboard bundled within the Rust binary.Key FeaturesAuto-Detection: * If a column has latitude & longitude -> Render Map.If a column name ends in _count or _price -> Render Line/Bar Chart.Embedded Assets: Use rust-embed to serve a pre-compiled Dioxus or React app from the /explore route.Live Stream: Implement a WebSocket or Server-Sent Events (SSE) endpoint at /v1/stream/:collection to push new data to the UI instantly.üõ°Ô∏è 4. Senior Engineer GuardrailsTo ensure production readiness, the following logic must be strictly enforced:WAL Mode Initiation: Always initialize the DB with:SQLPRAGMA journal_mode=WAL;
PRAGMA synchronous=NORMAL;
Transaction Safety: Use BEGIN IMMEDIATE for migrations to prevent deadlocks during high-concurrency writes.Parameter Binding: Never use string interpolation for values. The inference engine must convert serde_json::Value into libsql::Value.Column Limit: Hard-cap tables at 1,000 columns. If a JSON payload exceeds this, return 400 Bad Request to prevent "Schema Bloat" attacks.üìú 5. AI Agent Instructions (Claude Code / Cursor)Direct Directive: You are building VibeDB, a high-performance database wrapper.1. Data Integrity: Your primary goal is to ensure that no data is dropped. If a JSON key is new, the database must expand to accommodate it before the insert happens.2. Type Handling: Implement a robust match statement for serde_json::Value that maps to libsql::Value.3. Error Handling: Do not use .unwrap(). Use anyhow::Result and return meaningful error messages to the API consumer.4. Performance: Use DashMap for the schema cache. We should only hit the disk for PRAGMA table_info when absolutely necessary.5. Security: Sanitize all table and column names. Ensure they only contain alphanumeric characters and underscores. Use ? placeholders for all values.6. Embedding: Use rust-embed to serve the dashboard. Assume the dashboard assets are in ./ui/dist.